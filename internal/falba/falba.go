// Package falba contains core FALBA data model types.
package falba

import (
	"fmt"
	"io"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
)

var (
	// Reserved fact names that cannot be used by parsers
	reservedFactNames = map[string]bool{
		"test_name": true,
		"result_id": true,
	}
)

// IsReservedFactName returns true if the fact name conflicts with reserved column names
func IsReservedFactName(name string) bool {
	return reservedFactNames[name]
}

// GetReservedFactNamesString returns a comma-separated list of reserved fact names for error messages
func GetReservedFactNamesString() string {
	return strings.Join(slices.Collect(maps.Keys(reservedFactNames)), ", ")
}

// A Result is the outcome of running some test. The exact scope of this is up
// to the user to decide. The only constraint is that any given Fact can only
// have on value for a given Result.
type Result struct {
	// Name given by the user to describe the thing that was run to produce this
	// result.
	TestName string
	// Unique ID for this result. This is a hash generated by Falba to try and
	// avoid duplicate results.
	ResultID  string
	Artifacts []*Artifact
	Metrics   []*Metric
	// A Fact is a piece of information "about" a Result. This is intended for
	// representing factors that the user was deliberately controlling, or
	// factors that are "environmental". That is, these are the "inputs" of the
	// experiment.
	Facts map[string]Value
}

// ForResultsTable returns a representation of the Result that can be marshalled
// as JSON or whatever, containing only the stuff that's once-per-result, i.e.
// excluding metrics. Facts are flattened as direct columns.
func (r *Result) ForResultsTable() map[string]any {
	result := map[string]any{
		"test_name": r.TestName,
		"result_id": r.ResultID,
	}
	for name, val := range r.Facts {
		result[name] = ValueValue(val)
	}
	return result
}

// ForMetricsTable is like ForResultsTable but instead it just returns the
// metrics and the minimal key to join them against the result.
func (r *Result) ForMetricsTable() []map[string]any {
	var ret []map[string]any
	for _, metric := range r.Metrics {
		obj := map[string]any{
			"result_id": r.ResultID,
			"metric":    metric.Name,
		}
		obj[metric.Value.Type().MetricsColumn()] = ValueValue(metric.Value)
		ret = append(ret, obj)
	}
	return ret
}

func (r *Result) ResultDir(dbRoot string) string {
	return filepath.Join(dbRoot, fmt.Sprintf("%s:%s", r.TestName, r.ResultID))
}

// An Artifact is a file in the database, associated with a Result.
type Artifact struct {
	// The name is just the path relative to the artifacts dir.
	Name string
	Path string
}

func (a *Artifact) Content() ([]byte, error) {
	f, err := os.Open(a.Path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return io.ReadAll(f)
}

type ValueType int

const (
	ValueInt ValueType = iota
	ValueFloat
	ValueString
)

func (t ValueType) String() string {
	switch t {
	case ValueInt:
		return "int"
	case ValueFloat:
		return "float"
	case ValueString:
		return "string"
	default:
		panic(fmt.Sprintf("Invalid ValueType %d", t))
	}
}

// MetricsColumn returns the name of the column that's used to store metrics of
// this type in the metric table.
func (t ValueType) MetricsColumn() string {
	return fmt.Sprintf("%s_value", t)
}

func ParseValueType(s string) (ValueType, error) {
	switch s {
	case "int":
		return ValueInt, nil
	case "float":
		return ValueFloat, nil
	case "string":
		return ValueString, nil
	default:
		return 0, fmt.Errorf("unknown value type %q, expect 'int', 'float' or 'string'", s)
	}
}

// A Value is a value that can be stored as a Fact or a Metric.
type Value interface {
	// Type returns the type of the value, telling you which per-type method you
	// can call. If you call the wrong one you get the zero value.
	Type() ValueType
	IntValue() int64
	FloatValue() float64
	StringValue() string
}

type IntValue struct {
	Value int64
}

func (v *IntValue) Type() ValueType {
	return ValueInt
}

func (v *IntValue) IntValue() int64 {
	return v.Value
}

func (v *IntValue) FloatValue() float64 {
	return 0.0
}

func (v *IntValue) StringValue() string {
	return ""
}

type FloatValue struct {
	Value float64
}

func (v *FloatValue) Type() ValueType {
	return ValueFloat
}

func (v *FloatValue) IntValue() int64 {
	return 0
}

func (v *FloatValue) FloatValue() float64 {
	return v.Value
}

func (v *FloatValue) StringValue() string {
	return ""
}

type StringValue struct {
	Value string
}

func (v *StringValue) Type() ValueType {
	return ValueString
}

func (v *StringValue) IntValue() int64 {
	return 0
}

func (v *StringValue) FloatValue() float64 {
	return 0.0
}

func (v *StringValue) StringValue() string {
	return v.Value
}

func ValueValue(v Value) any {
	switch v.Type() {
	case ValueInt:
		return v.IntValue()
	case ValueFloat:
		return v.FloatValue()
	case ValueString:
		return v.StringValue()
	default:
		panic(fmt.Sprintf("Unknown value type %v", v.Type()))
	}
}

func ParseValue(s string, t ValueType) (Value, error) {
	switch t {
	case ValueInt:
		i, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as int: %v", s, err)
		}
		return &IntValue{Value: int64(i)}, nil
	case ValueFloat:
		f, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as float: %v", s, err)
		}
		return &FloatValue{Value: f}, nil
	case ValueString:
		return &StringValue{Value: s}, nil
	default:
		return nil, fmt.Errorf("invalid value type %v", t)
	}
}

// A Metric is an "output" captured in a Result. This is intended for
// representing the unknown that the experiment was intended to measure.
type Metric struct {
	Name string
	Value
}
