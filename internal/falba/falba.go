// Package falba contains core FALBA data model types.
package falba

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"io"
	"os"
	"strconv"
)

// A Result is the outcome of running some test. The exact scope of this is up
// to the user to decide. The only constraint is that any given Fact can only
// have on value for a given Result.
type Result struct {
	// Name given by the user to describe the thing that was run to produce this
	// result.
	TestName string
	// Unique ID for this result. This is a hash generated by Falba to try and
	// avoid duplicate results.
	ResultID  string
	Artifacts []*Artifact
	Metrics   []*Metric
	// A Fact is a piece of information "about" a Result. This is intended for
	// representing factors that the user was deliberately controlling, or
	// factors that are "environmental". That is, these are the "inputs" of the
	// experiment.
	Facts map[string]Value
}

// An Artifact is a file in the database, associated with a Result.
type Artifact struct {
	// The name is just the path relative to the artifacts dir.
	Name string
	Path string
}

func (a *Artifact) Content() ([]byte, error) {
	f, err := os.Open(a.Path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return io.ReadAll(f)
}

type ValueType int

const (
	ValueInt ValueType = iota
	ValueFloat
	ValueString
)

func (t ValueType) String() string {
	switch t {
	case ValueInt:
		return "int"
	case ValueFloat:
		return "float"
	case ValueString:
		return "string"
	default:
		panic(fmt.Sprintf("Invalid ValueType %d", t))
	}
}

func ParseValueType(s string) (ValueType, error) {
	switch s {
	case "int":
		return ValueInt, nil
	case "float":
		return ValueFloat, nil
	case "string":
		return ValueString, nil
	default:
		return 0, fmt.Errorf("unknown value type %q, expect 'int', 'float' or 'string'", s)
	}
}

func (t ValueType) SQL() string {
	switch t {
	case ValueInt:
		return "INT64"
	case ValueFloat:
		return "FLOAT"
	case ValueString:
		return "STRING"
	default:
		panic(fmt.Sprintf("unknown value type %d", t))
	}
}

// Return a NULL value of this type, prepared for insertion into an SQL table.
// This is kinda awkward because you cannot have a typed and nil falba Value.
func (t ValueType) SQLNull() driver.Valuer {
	switch t {
	case ValueInt:
		return sql.NullInt64{}
	case ValueFloat:
		return sql.NullFloat64{}
	case ValueString:
		return sql.NullString{}
	default:
		panic(fmt.Sprintf("unknown value type %d", t))
	}
}

// A Value is a value that can be stored as a Fact or a Metric.
type Value interface {
	// Type returns the type of the value, telling you which per-type method you
	// can call. If you call the wrong one you get the zero value.
	Type() ValueType
	IntValue() int64
	FloatValue() float64
	StringValue() string
	SQLValue() driver.Valuer
}

type IntValue struct {
	Value int64
}

func (v *IntValue) Type() ValueType {
	return ValueInt
}

func (v *IntValue) IntValue() int64 {
	return v.Value
}

func (v *IntValue) FloatValue() float64 {
	return 0.0
}

func (v *IntValue) StringValue() string {
	return ""
}

func (v *IntValue) SQLValue() driver.Valuer {
	return sql.NullInt64{Valid: true, Int64: v.Value}
}

type FloatValue struct {
	Value float64
}

func (v *FloatValue) Type() ValueType {
	return ValueFloat
}

func (v *FloatValue) IntValue() int64 {
	return 0
}

func (v *FloatValue) FloatValue() float64 {
	return v.Value
}

func (v *FloatValue) StringValue() string {
	return ""
}

func (v *FloatValue) SQLValue() driver.Valuer {
	return sql.NullFloat64{Valid: true, Float64: v.Value}
}

type StringValue struct {
	Value string
}

func (v *StringValue) Type() ValueType {
	return ValueString
}

func (v *StringValue) IntValue() int64 {
	return 0
}

func (v *StringValue) FloatValue() float64 {
	return 0.0
}

func (v *StringValue) StringValue() string {
	return v.Value
}

func (v *StringValue) SQLValue() driver.Valuer {
	return sql.NullString{Valid: true, String: v.Value}
}

func ParseValue(s string, t ValueType) (Value, error) {
	switch t {
	case ValueInt:
		i, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as int: %v", s, err)
		}
		return &IntValue{Value: int64(i)}, nil
	case ValueFloat:
		f, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as float: %v", s, err)
		}
		return &FloatValue{Value: f}, nil
	case ValueString:
		return &StringValue{Value: s}, nil
	default:
		return nil, fmt.Errorf("invalid value type %v", t)
	}
}

// A Metric is an "output" captured in a Result. This is intended for
// representing the unknown that the experiment was intended to measure.
type Metric struct {
	Name string
	Value
}
