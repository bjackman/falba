// Package falba contains core FALBA data model types.
package falba

import (
	"fmt"
	"io"
	"os"
	"strconv"
)

// A Result is the outcome of running some test. The exact scope of this is up
// to the user to decide. The only constraint is that any given Fact can only
// have on value for a given Result.
type Result struct {
	// Name given by the user to describe the thing that was run to produce this
	// result.
	TestName string
	// Unique ID for this result. This is a hash generated by Falba to try and
	// avoid duplicate results.
	TestID    string
	Artifacts []*Artifact
	Metrics   []*Metric
	// A Fact is a piece of information "about" a Result. This is intended for
	// representing factors that the user was deliberately controlling, or
	// factors that are "environmental". That is, these are the "inputs" of the
	// experiment.
	Facts map[string]Value
}

// An Artifact is a file in the database, associated with a Result.
type Artifact struct {
	Path string
}

func (a *Artifact) Content() ([]byte, error) {
	f, err := os.Open(a.Path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return io.ReadAll(f)
}

type ValueType int

const (
	ValueInt ValueType = iota
	ValueFloat
	ValueString
)

// A Value is a value that can be stored as a Fact or a Metric.
type Value interface {
	// Type returns the type of the value, telling you which per-type method you
	// can call. If you call the wrong one you get the zero value.
	Type() ValueType
	IntValue() int
	FloatValue() float64
	StringValue() string
}

type IntValue struct {
	Value int
}

func (v *IntValue) Type() ValueType {
	return ValueInt
}

func (v *IntValue) IntValue() int {
	return v.Value
}

func (v *IntValue) FloatValue() float64 {
	return 0.0
}

func (v *IntValue) StringValue() string {
	return ""
}

type FloatValue struct {
	Value float64
}

func (v *FloatValue) Type() ValueType {
	return ValueFloat
}

func (v *FloatValue) IntValue() int {
	return 0
}

func (v *FloatValue) FloatValue() float64 {
	return v.Value
}

func (v *FloatValue) StringValue() string {
	return ""
}

type StringValue struct {
	Value string
}

func (v *StringValue) Type() ValueType {
	return ValueString
}

func (v *StringValue) IntValue() int {
	return 0
}

func (v *StringValue) FloatValue() float64 {
	return 0.0
}

func (v *StringValue) StringValue() string {
	return v.Value
}

func ParseValue(s string, t ValueType) (Value, error) {
	switch t {
	case ValueInt:
		i, err := strconv.ParseInt(s, 0, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as int: %v", s, err)
		}
		return &IntValue{Value: int(i)}, nil
	case ValueFloat:
		f, err := strconv.ParseFloat(s, 64)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse %s as float: %v", s, err)
		}
		return &FloatValue{Value: f}, nil
	case ValueString:
		return &StringValue{Value: s}, nil
	default:
		return nil, fmt.Errorf("invalid value type %v", t)
	}
}

// A Metric is an "output" captured in a Result. This is intended for
// representing the unknown that the experiment was intended to measure.
type Metric struct {
	Name string
	Value
}
